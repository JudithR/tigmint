#!/usr/bin/make -rRf
# Correct misassemblies using Tigmint
# Written by Shaun Jackman @sjackman

# Usage:
# tigmint-make draft=myassembly reads=myreads

# To run Tigmint and calculate assembly metrics:
# tigmint-make draft=myassembly reads=myreads ref=GRCh38 G=3088269832

# Name of the draft assembly, draft.fa
draft=draft

# Name of the reads, reads.fq.gz, after running longranger basic
reads=reads

# Reference genome, ref.fa, for calculating assembly contiguity metrics
#ref=ref

# Size of the reference genome, for calculating NG50 and NGA50
#G=0

# Select positions with low depth of coverage and high number of molecule starts.
depth_threshold=100
starts_threshold=4
pos_threshold=1000

# Minimum molecule size
minsize=2000

# Minimum alignment score
as=100

# Maximum number of mismatches
nm=5

# Parameters of ARCS
c=5
e=30000
r=0.05

# Parameters of LINKS
a=0.1
l=10

# Number of threads
t=8

# gzip compression program, use pigz for parallelized compression
gzip=gzip
#gzip=pigz -p$t

# Report run time and memory usage using zsh
ifdef time
export SHELL=zsh -opipefail
export REPORTTIME=1
export TIMEFMT=time user=%U system=%S elapsed=%E cpu=%P memory=%M job=%J
else
export SHELL=sh -opipefail
endif

.DELETE_ON_ERROR:
.SECONDARY:
.PHONY: all tigmint arcs metrics draft_metrics tigmint_metrics arcs_metrics

all: tigmint arcs
ifdef ref
ifdef G
all: metrics
endif
endif

metrics: draft_metrics tigmint_metrics arcs_metrics

# Calculate assembly metrics of the draft assembly using abyss-fac and abyss-samtobreak
draft_metrics: \
	$(draft).abyss-fac.tsv \
	$(draft).scaftigs.abyss-fac.tsv \
	$(draft).scaftigs.$(ref).samtobreak.tsv

# Correct misassemblies using Tigmint
tigmint: \
	$(draft).$(reads).bx.bam.bai \
	$(draft).$(reads).bx.as$(as).nm$(nm).bam.bai \
	$(draft).$(reads).bx.as$(as).nm$(nm).bam.mi.bx.molecule.summary.html \
	$(draft).$(reads).bx.as$(as).nm$(nm).bam.mi.bx.molecule.size$(minsize).bed.genomecov.stats.tsv \
	$(draft).$(reads).bx.as$(as).nm$(nm).bam.mi.bx.molecule.size$(minsize).depth$(depth_threshold).starts.breakpoints.tigs.fa \
	$(draft).tigmint.fa

# Calculate assembly metrics after Tigmint
tigmint_metrics: \
	$(draft).$(reads).bx.as$(as).nm$(nm).bam.mi.bx.molecule.size$(minsize).depth$(depth_threshold).starts.breakpoints.tigs.abyss-fac.tsv \
	$(draft).$(reads).bx.as$(as).nm$(nm).bam.mi.bx.molecule.size$(minsize).depth$(depth_threshold).starts.breakpoints.tigs.scaftigs.abyss-fac.tsv \
	$(draft).$(reads).bx.as$(as).nm$(nm).bam.mi.bx.molecule.size$(minsize).depth$(depth_threshold).starts.breakpoints.tigs.scaftigs.$(ref).samtobreak.tsv

# Scaffold using ARCS
arcs: \
	$(draft).$(reads).bx.as$(as).nm$(nm).bam.mi.bx.molecule.size$(minsize).depth$(depth_threshold).starts.breakpoints.tigs.$(reads).c$c_e$e_r$r.arcs.a$a_l$l.links.fa \
	$(draft).tigmint.arcs.fa

# Calculate assembly metrics after ARCS
arcs_metrics: \
	$(draft).$(reads).bx.as$(as).nm$(nm).bam.mi.bx.molecule.size$(minsize).depth$(depth_threshold).starts.breakpoints.tigs.$(reads).c$c_e$e_r$r.arcs.a$a_l$l.links.abyss-fac.tsv \
	$(draft).$(reads).bx.as$(as).nm$(nm).bam.mi.bx.molecule.size$(minsize).depth$(depth_threshold).starts.breakpoints.tigs.$(reads).c$c_e$e_r$r.arcs.a$a_l$l.links.scaftigs.abyss-fac.tsv \
	$(draft).$(reads).bx.as$(as).nm$(nm).bam.mi.bx.molecule.size$(minsize).depth$(depth_threshold).starts.breakpoints.tigs.$(reads).c$c_e$e_r$r.arcs.a$a_l$l.links.scaftigs.$(ref).samtobreak.tsv

# Symlink the Tigmint results
$(draft).tigmint.fa: $(draft).$(reads).bx.as$(as).nm$(nm).bam.mi.bx.molecule.size$(minsize).depth$(depth_threshold).starts.breakpoints.tigs.fa
	ln -sf $< $@

# Symlink the ARCS results
$(draft).tigmint.arcs.fa: $(draft).$(reads).bx.as$(as).nm$(nm).bam.mi.bx.molecule.size$(minsize).depth$(depth_threshold).starts.breakpoints.tigs.$(reads).c$c_e$e_r$r.arcs.a$a_l$l.links.fa
	ln -sf $< $@

# Add the barcode to the read ID, and skip reads without barcodes.
%.bx.fq.gz: %.fq.gz
	gunzip -c $< | gawk ' \
		{ bx = "NA" } \
		match($$0, "BX:Z:([ACGT]*)-1", x) { bx = x[1] } \
		bx == "NA" { getline; getline; getline; next } \
		{ print $$1 "_" bx " " $$2; getline; print; getline; print; getline; print }' \
		| $(gzip) >$@

# BWA

# Index the genome.
%.fa.bwt: %.fa
	bwa index $<

# Align paired-end reads to the draft genome and sort.
$(draft).%.bam: %.fq.gz $(draft).fa.bwt
	bwa mem -t$t -pC $(draft).fa $< | samtools view -h -F4 | samtools sort -@$t -o $@

# samtools

# Index a FASTA file.
%.fa.fai: %.fa
	samtools faidx $<

# Index a BAM file.
%.bam.bai: %.bam
	samtools index $<

# Remove alignments with an alignment score below a threshold.
%.as100.bam: %.bam
	samtools view -h -F4 $< | gawk -F'\t' ' \
			/^@/ { print; next } \
			{ as = 0 } \
			match($$0, "AS:.:([^\t]*)", x) { as = x[1] } \
			as >= 100' \
		| samtools view -@$t -b -o $@

# Select alignments with number of mismatches below a threshold.
%.nm$(nm).bam: %.bam
	samtools view -h -F4 $< \
		| gawk -F'\t' ' \
			/^@/ { print; next } \
			{ nm = 999999999 } \
			match($$0, "NM:i:([^\t]*)", x) { nm = x[1] } \
			nm < $(nm)' \
		| samtools view -@$t -b -o $@

# Extract the alignment score, barcode and molecule identifier.
%.bam.bx.tsv: %.bam
	samtools view -F4 $< | gawk -F'\t' ' \
		BEGIN { print "Flags\tRname\tPos\tMapq\tAS\tNM\tBX\tMI" } \
		{ as = bx = mi = nm = "NA" } \
		match($$0, "AS:.:([^\t]*)", x) { as = x[1] } \
		match($$0, "NM:.:([^\t]*)", x) { nm = x[1] } \
		match($$0, "BX:Z:([^\t]*)", x) { bx = x[1] } \
		match($$0, "MI:i:([^\t]*)", x) { mi = x[1] } \
		{ print $$2 "\t" $$3 "\t" $$4 "\t" $$5 "\t" as "\t" nm "\t" bx "\t" mi }' >$@

# Group reads into molecules and add molecule identifiers.
%.bam.mi.bx.tsv: %.bam.bx.tsv
	./mi.r $< $@

# Create a TSV file of molecule extents.
%.bx.molecule.tsv: %.bx.tsv
	mlr --tsvlite \
		then stats1 -g BX,MI,Rname -a count,min,p50,max -f Pos,Mapq,AS,NM \
		then rename Pos_min,Start,Pos_max,End,Mapq_p50,Mapq_median,AS_p50,AS_median,NM_p50,NM_median,Pos_count,Reads \
		then put '$$Size = $$End - $$Start' \
		then cut -o -f Rname,Start,End,Size,BX,MI,Reads,Mapq_median,AS_median,NM_median \
		then filter '$$Reads >= 4' \
		$< >$@

# Create a BED file of molecule extents.
%.bx.molecule.bed: %.bx.molecule.tsv
	mlr --tsvlite --headerless-csv-output \
		put '$$Start = $$Start - 1; $$End = $$End - 1' \
		then put '$$Name = "Reads=" . $$Reads . ",Size=" . $$Size . ",Mapq=" . $$Mapq_median . ",AS=" . $$AS_median . ",NM=" . $$NM_median . ",BX=" . $$BX . ",MI=" . $$MI' \
		then cut -o -f Rname,Start,End,Name,Reads $< >$@

# Report summary statistics of a Chromium library
%.bx.molecule.summary.html: %.bx.molecule.tsv
	Rscript -e 'rmarkdown::render("summary.rmd", "html_document", "$@", params = list(input_tsv="$<", output_tsv="$*.summary.tsv"))'

# bedtools

# Convert BED to BAM.
%.bed.bam: %.bed $(draft).fa.fai
	awk '$$2 != $$3' $< | bedtools bedtobam -i - -g $(draft).fa.fai | samtools sort -@$t -Obam -o $@

# Compute the depth of coverage of a BAM file.
%.bam.depth.tsv: %.bam
	(printf "Rname\tPos\tDepth\n"; bedtools genomecov -d -ibam $<) >$@

# Compute the depth of coverage of a BED file.
%.bed.depth.tsv: %.bed $(draft).fa.fai
	(printf "Rname\tPos\tDepth\n"; awk '$$2 != $$3' $< | bedtools genomecov -d -g $(draft).fa.fai -i -) >$@

# Calculate depth of coverage statistics.
%.depth.stats.tsv: %.depth.tsv
	mlr --tsvlite stats1 -a count,p25,p50,p75,mean,stddev -f Depth $< >$@

# Calculate depth of coverage statistics per sequence.
%.depth.seqstats.tsv: %.depth.tsv
	mlr --tsvlite stats1 -a count,p25,p50,p75,mean,stddev -f Depth -g Rname $< >$@

# Compute statistics on the depth of coverage of a BED file.
%.bed.genomecov.tsv: %.bed $(draft).fa.fai
	(printf "Rname\tDepth\tCount\tRsize\tFraction\n"; awk '$$2 != $$3' $< | bedtools genomecov -g $(draft).fa.fai -i -) >$@

# Calculate depth of coverage statistics from bedtools genomecov.
%.genomecov.stats.tsv: %.genomecov.tsv
	mlr --tsvlite \
		then filter '$$Rname == "genome" && $$Depth > 0' \
		then step -a rsum -f Fraction \
		then put -q '@Depth_count += $$Count; if (is_null(@p25) && $$Fraction_rsum >= 0.25) { @p25 = $$Depth }; if (is_null(@p50) && $$Fraction_rsum >= 0.50) { @p50 = $$Depth }; if (is_null(@p75) && $$Fraction_rsum >= 0.75) { @p75 = $$Depth } end { emitf @Depth_count, @p25, @p50, @p75 }' \
		then rename p25,Depth_p25,p50,Depth_p50,p75,Depth_p75 \
		then put '$$Depth_IQR = $$Depth_p75 - $$Depth_p25' \
		$< >$@

# Identify breakpoints

# Select BED records of a given size or larger.
%.size$(minsize).bed: %.bed
	awk '$$3 - $$2 >= $(minsize)' $< >$@

# Count start positions of molecules larger than a threshold size.
starts_size_threshold=2000
%.molecule.starts.tsv: %.molecule.tsv
	mlr --tsvlite \
		then filter '$$Size >= $(starts_size_threshold)' \
		then count-distinct -f Rname,Start \
		then rename Start,Pos,count,Starts \
		then sort -f Rname -n Pos \
		$< >$@

# Select position below the coverage threshold.
%.depth$(depth_threshold).tsv: %.depth.tsv
	mlr --tsvlite filter '$$Depth < $(depth_threshold)' $< >$@

# Join the tables of depth of coverage and number of molecule starts.
%.molecule.size$(minsize).depth$(depth_threshold).starts.tsv: %.molecule.size$(minsize).bed.depth$(depth_threshold).tsv %.molecule.starts.tsv
	mlr --tsvlite join -u -j Rname,Pos -f $^ >$@

# Select positions with low depth of coverage and high number of molecule starts.
%.depth$(depth_threshold).starts.breakpoints.tsv: %.depth$(depth_threshold).starts.tsv
	mlr --tsvlite filter '$$Depth < $(depth_threshold) && $$Starts >= $(starts_threshold) && $$Pos >= $(pos_threshold)' $< >$@

# Identify breakpoints with low depth of coverage and high number of molecule starts.
%.size$(minsize).depth.starts.breakpoints.tsv: %.size$(minsize).bed.depth.tsv %.starts.tsv
	Rscript -e 'rmarkdown::render("breakpoints.rmd", "html_notebook", "$*.depth.starts.breakpoints.nb.html", params = list(depth_tsv="$<", starts_tsv="$*.starts.tsv", depth_starts_tsv="$*.depth.starts.tsv", breakpoints_tsv="$@"))'

# Determine coordinates of the breaktig subsequences.
%.breakpoints.tigs.bed: %.breakpoints.tsv $(draft).fa.fai
	Rscript -e 'rmarkdown::render("breaktigs.rmd", "html_notebook", "$*.breakpoints.tigs.nb.html", params = list(input_tsv="$<", input_fai="$(draft).fa.fai", output_bed="$@"))'

# Break scaffolds at the breakpoints.
%.breakpoints.tigs.fa: %.breakpoints.tigs.bed $(draft).fa
	bedtools getfasta -name -fi $(draft).fa -bed $< | sed 's/::/ /;s/^NN*//;s/NN*$$//' >$@

################################################################################
# Calculate assembly contiguity and correctness metrics.

# BWA

# Align an assembly to the reference using BWA-MEM.
%.$(ref).sam: %.fa $(ref).fa.bwt
	bwa mem -xintractg -t$t $(ref).fa $< >$@

# Align paired-end reads to the draft genome and do not sort.
%.$(reads).bx.sortn.bam: %.fa.bwt $(reads).bx.fq.gz
	bwa mem -t$t -pC $*.fa $(reads).bx.fq.gz | samtools view -@$t -h -F4 -o $@

# ARCS

# Create a graph of linked contigs using ARCS.
%.$(reads).c$c_e$e_r$r.arcs_original.gv %.$(reads).c$c_e$e_r$r.arcs.dist.gv %.$(reads).c$c_e$e_r$r.arcs.dist.tsv: %.$(reads).bx.sortn.bam %.fa
	arcs -s98 -c$c -l0 -z500 -m4-20000 -d0 -e$e -r$r -v \
		-f $*.fa \
		-b $*.$(reads).c$c_e$e_r$r.arcs \
		-g $*.$(reads).c$c_e$e_r$r.arcs.dist.gv \
		--tsv=$*.$(reads).c$c_e$e_r$r.arcs.dist.tsv \
		--barcode-counts=$<.barcode-counts.tsv \
		$<

# Convert the ARCS graph to LINKS TSV format.
%.$(reads).c$c_e$e_r$r.arcs.links.tsv: %.$(reads).c$c_e$e_r$r.arcs_original.gv %.fa
	bin/arcs-makeTSVfile $< $@ $*.fa

# Scaffold the assembly using the ARCS graph and LINKS.
%.$(reads).c$c_e$e_r$r.arcs.a$a_l$l.links.scaffolds.fa %.$(reads).c$c_e$e_r$r.arcs.a$a_l$l.links.assembly_correspondence.tsv: %.$(reads).c$c_e$e_r$r.arcs.links.tsv %.fa
	cp $< $*.$(reads).c$c_e$e_r$r.arcs.a$a_l$l.links.tigpair_checkpoint.tsv
	LINKS -k20 -l$l -t2 -a$a -x1 -s /dev/null -f $*.fa -b $*.$(reads).c$c_e$e_r$r.arcs.a$a_l$l.links

# Rename the scaffolds.
%.links.fa: %.links.scaffolds.fa
	gsed -r 's/^>scaffold([^,]*),(.*)/>\1 scaffold\1,\2/' $< >$@

# ABySS

# Convert scaffolds to scaftigs.
%.scaftigs.fa: %.fa
	seqtk seq $< | tr _ '~' | abyss-fatoagp -f $@ >$@.agp

# Calculate assembly contiguity metrics with abyss-fac.
%.abyss-fac.tsv: %.fa
	abyss-fac -G$G -t500 $< >$@

# Calculate assembly contiguity and correctness metrics.
%.samtobreak.txt: %.sam
	(echo '==> $< <=='; abyss-samtobreak -G$G -l500 $<) >$@

# Convert samtobreak.txt to TSV.
%.samtobreak.tsv: %.samtobreak.txt
	bin/abyss-samtobreak-to-tsv $< >$@
